import "./../assets/scss/MainScreen.scss";
import { useState, useRef, useEffect, useContext } from "react";
import { GlobalContext } from "./GlobalContext.jsx";
import RadioDevice from "./RadioDevice.jsx";
import RadioDeviceImg from "./RadioDeviceImg.jsx";
import { THEMES } from "../constants/constants.jsx";

export default function MainScreen({ solvePuzzle, solved, solvedTrigger }) {
    const { appSettings: config, Storage } = useContext(GlobalContext);

    const MIN_FREQ = config.range?.min;
    const MAX_FREQ = config.range?.max;
    const STEP = config.step;
    const TOLERANCE = config.tolerance;
    const [isClicked, setIsClicked] = useState(false);
    const [frequency, setFrequency] = useState(() => {
        const stored = Storage?.getSetting("frequency");
        return stored ? parseFloat(stored) : (config.range?.min);
    });
    const [volume, setVolume] = useState(() => {
        const stored = Storage?.getSetting("volume");
        return stored ? parseFloat(stored) : 0.5;
    });

    // Save state to storage on change
    useEffect(() => {
        if (Storage) {
            Storage.saveSetting("frequency", frequency);
        }
    }, [frequency, Storage]);

    useEffect(() => {
        if (Storage) {
            Storage.saveSetting("volume", volume);
        }
    }, [volume, Storage]);

    const audioCtxRef = useRef(null);
    const staticNodeRef = useRef(null);
    const staticGainRef = useRef(null);
    const stationNodesRef = useRef({}); // { freq: { element: Audio, gain: GainNode, source: MediaElementSource } }
    const masterGainRef = useRef(null);

    // Initialize Audio Context
    useEffect(() => {
        if (!config.stations) return;

        const AudioContext = window.AudioContext || window.webkitAudioContext;
        const ctx = new AudioContext();
        audioCtxRef.current = ctx;

        // Master Gain (Volume)
        const masterGain = ctx.createGain();
        masterGain.gain.value = volume;
        masterGain.connect(ctx.destination);
        masterGainRef.current = masterGain;

        // 1. Setup Static Noise ( generated by code)
        setupWhiteNoise(ctx, masterGain);

        // 2. Setup Stations
        config.stations.forEach(station => {
            const audio = new Audio(station.url);
            audio.loop = true;
            audio.crossOrigin = "anonymous";
            audio.volume = volume;

            // Save ref
            stationNodesRef.current[station.freq] = { audio, config: station };
        });

        return () => {
            // Cleanup
            if (audioCtxRef.current) audioCtxRef.current.close();
            Object.values(stationNodesRef.current).forEach(n => {
                n.audio.pause();
                n.audio.src = "";
            });
        };
    }, []);

    useEffect(() => {
        let maxSignal = 0;

        // Check each station
        Object.values(stationNodesRef.current).forEach(({ audio, config }) => {
            const dist = Math.abs(frequency - config.freq);
            let signal = 0;

            if (dist < TOLERANCE) {
                signal = 1 - (dist / TOLERANCE);
            }

            if (signal > maxSignal) maxSignal = signal;
            audio.volume = signal * volume;

            if (signal > 0 && audio.paused) {
                const p = audio.play();
                if (p) p.catch(() => { });
            } else if (signal === 0 && !audio.paused) {
                audio.pause();
            }
        });

        if (staticGainRef.current) {
            const staticVal = (1 - maxSignal) * volume * 0.3;
            staticGainRef.current.gain.setTargetAtTime(staticVal, audioCtxRef.current.currentTime, 0.1);
        }

    }, [frequency, volume, solved, isClicked]);

    useEffect(() => {
        const stations = config.stations;
        if (stations && !solved) {
            const tunedStation = stations.find(station => Math.abs(frequency - station.freq) < (TOLERANCE / 4));

            if (tunedStation) {
                const timer = setTimeout(() => {
                    solvePuzzle(frequency); // Pass frequency as solution
                }, 5000);
                return () => clearTimeout(timer);
            }
        }
    }, [frequency, solved, config]);

    const setupWhiteNoise = (ctx, masterGain) => {
        const bufferSize = ctx.sampleRate * 2;
        const buffer = ctx.createBuffer(1, bufferSize, ctx.sampleRate);
        const data = buffer.getChannelData(0);

        for (let i = 0; i < bufferSize; i++) {
            data[i] = Math.random() * 2 - 1;
        }

        const source = ctx.createBufferSource();
        source.buffer = buffer;
        source.loop = true;
        const gain = ctx.createGain();
        gain.gain.value = 0.5;
        source.connect(gain);
        gain.connect(masterGain);
        source.start();
        staticNodeRef.current = source;
        staticGainRef.current = gain;
    };

    const handleInteraction = () => {
        if (audioCtxRef.current && audioCtxRef.current.state === 'suspended') {
            audioCtxRef.current.resume();
        }
        setIsClicked(true);
    };

    const skinClass = config?.skin ? `skin-${config.skin.toLowerCase()}` : 'skin-standard';

    return (
        <div className={`mainScreen ${skinClass}`} onClick={handleInteraction}>
            {THEMES.STANDARD === config.skin ? <RadioDevice
                frequency={frequency}
                setFrequency={setFrequency}
                volume={volume}
                setVolume={setVolume}
                minFreq={MIN_FREQ}
                maxFreq={MAX_FREQ}
                step={STEP}
            /> : <RadioDeviceImg
                config={config}
                frequency={frequency}
                setFrequency={setFrequency}
                volume={volume}
                setVolume={setVolume}
                minFreq={MIN_FREQ}
                maxFreq={MAX_FREQ}
                step={STEP}
            />}
        </div>
    );
}
